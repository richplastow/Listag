// Generated by CoffeeScript 1.9.2
(function(global) {
/*! Listag 0.0.16 //// MIT Licence //// http://listag.richplastow.com/ */
var ID_RULE, Listag, Node, TAG_RULE, Tudor, oo, removeTag, summarizeAndFilterNodes, summarizeNodes, tudor,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

if ('undefined' === typeof console || !console.log) {
  oo = function() {};
} else if ('object' === typeof console.log) {
  oo = Function.prototype.bind(console.log, console);
} else {
  oo = console.log.bind(console);
}

oo.G = global;

oo.T = 'Listag';

oo.V = '0.0.16';

oo.A = 'array';

oo.B = 'boolean';

oo.D = 'document';

oo.E = 'error';

oo.F = 'function';

oo.I = 'integer';

oo.N = 'number';

oo.O = 'object';

oo.R = 'regexp';

oo.S = 'string';

oo.U = 'undefined';

oo.X = 'null';

oo._ = (Math.random().toString(36) + '00000000').substr(2, 8);

oo.is = function(c, t, f) {
  if (t == null) {
    t = true;
  }
  if (f == null) {
    f = false;
  }
  if (c) {
    return t;
  } else {
    return f;
  }
};

oo.isU = function(x) {
  return oo.U === typeof x;
};

oo.isX = function(x) {
  return null === x;
};

oo.type = function(a) {
  var ta;
  if (oo.isX(a)) {
    return oo.X;
  }
  ta = typeof a;
  if ({
    undefined: 1,
    string: 1,
    number: 1,
    boolean: 1
  }[ta]) {
    return ta;
  }
  if (!a.nodeName && a.constructor !== Array && /function/i.test('' + a)) {
    return oo.F;
  }
  return {}.toString.call(a).match(/\s([a-z0-9]+)/i)[1].toLowerCase();
};

oo.ex = function(x, a, b) {
  var pos;
  if (-1 === (pos = a.indexOf(x))) {
    return x;
  } else {
    return b.charAt(pos);
  }
};

oo.has = function(h, n, t, f) {
  if (t == null) {
    t = true;
  }
  if (f == null) {
    f = false;
  }
  if (-1 !== h.indexOf(n)) {
    return t;
  } else {
    return f;
  }
};

oo.uid = function(p) {
  if (p == null) {
    p = 'id';
  }
  return p + '_' + (Math.random().toString(36) + '00000000').substr(2, 8);
};

oo.uid62 = function(p, l) {
  var c;
  if (p == null) {
    p = 'id';
  }
  if (l == null) {
    l = 8;
  }
  c = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
  return p + '_' + ((function() {
    var results;
    results = [];
    while (l--) {
      results.push(c.charAt(Math.floor(Math.random() * 62)));
    }
    return results;
  })()).join('');
};

oo.pad = function(s, l, c) {
  if (c == null) {
    c = ' ';
  }
  return s + Array(l - s.length + 1).join(c);
};

oo.insert = function(basis, overlay, offset) {
  return basis.slice(0, offset) + overlay + basis.slice(offset + overlay.length);
};

oo.define = function(obj, name, value, kind) {
  switch (kind) {
    case 'constant':
      return Object.defineProperty(obj, name, {
        value: value,
        enumerable: true
      });
    case 'hid':
      return Object.defineProperty(obj, name, {
        value: value,
        enumerable: false
      });
  }
};

oo.lock = function(obj) {
  var j, key, len, ref;
  ref = Object.keys(obj);
  for (j = 0, len = ref.length; j < len; j++) {
    key = ref[j];
    Object.defineProperty(obj, key, {
      writable: false,
      configurable: false
    });
  }
  Object.preventExtensions(obj);
  if (obj.prototype && obj !== obj.prototype) {
    return oo.lock(obj.prototype);
  }
};

oo.vArray = function(M, arr, signature, fallback) {
  var i, j, k, len, len1, matches, max, min, pass, ref, ref1, rule, tv, type, types, value;
  matches = signature.match(/^<\[([|a-z]+)\s*(.*)\]>$/i);
  if (!matches) {
    throw RangeError("/listag/oopish/oo-helpers.litcoffee oo.vArray()\n  signature " + signature + " is invalid");
  }
  signature = matches[0], types = matches[1], rule = matches[2];
  if (!arr) {
    return fallback;
  }
  if (oo.A !== oo.type(arr)) {
    throw RangeError(M + (" is type " + (oo.type(arr)) + " not array"));
  }
  for (i = j = 0, len = arr.length; j < len; i = ++j) {
    value = arr[i];
    tv = oo.type(value);
    pass = false;
    ref = types.split('|');
    for (k = 0, len1 = ref.length; k < len1; k++) {
      type = ref[k];
      if ((oo.N === type || oo.I === type) && oo.N === tv) {
        if (oo.I === type && value % 1) {
          throw RangeError(M + ("[" + i + "] is a number but not an integer"));
        }
        if (rule) {
          ref1 = rule.split('-'), min = ref1[0], max = ref1[1];
          if (value < min || value > max) {
            throw RangeError(M + ("[" + i + "] is " + value + " (must be " + rule + ")"));
          }
        }
        pass = true;
        break;
      }
      if (type === tv) {
        if (oo.S === tv && rule) {
          if (!RegExp(rule).test(value)) {
            throw RangeError(M + ("[" + i + "] fails " + rule));
          }
        }
        pass = true;
        break;
      }
      if (/^[A-Z]/.test(type)) {
        if (oo.O === tv) {
          if (eval("value instanceof " + type)) {
            pass = true;
            break;
          }
        }
      }
    }
    if (pass) {
      continue;
    }
    throw TypeError(M + ("[" + i + "] is type " + tv + " not " + types));
  }
  return arr;
};

oo.vArg = function(M, value, signature, fallback) {
  var j, key, len, matches, max, min, pfx, ref, ref1, rule, tv, type, types;
  matches = signature.match(/^([_a-z][_a-z0-9]*)\s+<([|a-z]+)\s*(.*)>$/i);
  if (!matches) {
    throw RangeError("/listag/oopish/oo-helpers.litcoffee oo.vArg()\n  signature " + signature + " is invalid");
  }
  signature = matches[0], key = matches[1], types = matches[2], rule = matches[3];
  pfx = M + ("argument " + key + " ");
  tv = oo.type(value);
  if (oo.U === tv) {
    if (4 === arguments.length) {
      return fallback;
    }
    throw TypeError(pfx + "is undefined and has no fallback");
  }
  ref = types.split('|');
  for (j = 0, len = ref.length; j < len; j++) {
    type = ref[j];
    if ((oo.N === type || oo.I === type) && oo.N === tv) {
      if (oo.I === type && value % 1) {
        throw RangeError(pfx + "is a number but not an integer");
      }
      if (rule) {
        ref1 = rule.split('-'), min = ref1[0], max = ref1[1];
        if (value < min || value > max) {
          throw RangeError(pfx + ("is " + value + " (must be " + rule + ")"));
        }
      }
      return value;
    }
    if (type === tv) {
      if (oo.S === tv && rule) {
        if (!RegExp(rule).test(value)) {
          throw RangeError(pfx + ("fails " + rule));
        }
      }
      return value;
    }
    if (/^[A-Z]/.test(type)) {
      if (oo.O === tv) {
        if (eval("value instanceof " + type)) {
          return value;
        }
      }
    }
  }
  throw TypeError(pfx + ("is type " + tv + " not " + types));
};

oo.vObject = function(M, objName, obj) {
  if (oo.O !== oo.type(obj)) {
    throw TypeError(M + objName + (" is type " + (oo.type(obj)) + " not object"));
  }
  return function(signature, fallback) {
    var j, key, len, matches, max, min, ref, ref1, rule, tv, type, types, value;
    matches = signature.match(/^([_a-z][_a-z0-9]*)\s+<([|a-z]+)\s*(.*)>$/i);
    if (!matches) {
      throw RangeError("/listag/oopish/oo-helpers.litcoffee oo.vObject()\n  signature " + signature + " is invalid");
    }
    signature = matches[0], key = matches[1], types = matches[2], rule = matches[3];
    value = obj[key];
    tv = oo.type(value);
    if (oo.U === tv) {
      if (2 === arguments.length) {
        return fallback;
      }
      throw TypeError(M + objName + '.' + key + " is undefined and has no fallback");
    }
    ref = types.split('|');
    for (j = 0, len = ref.length; j < len; j++) {
      type = ref[j];
      if ((oo.N === type || oo.I === type) && oo.N === tv) {
        if (oo.I === type && value % 1) {
          throw RangeError(M + objName + '.' + key + " is a number but not an integer");
        }
        if (rule) {
          ref1 = rule.split('-'), min = ref1[0], max = ref1[1];
          if (value < min || value > max) {
            throw RangeError(M + objName + '.' + key + (" is " + value + " (must be " + rule + ")"));
          }
        }
        return value;
      }
      if (type === tv) {
        if (oo.S === tv && rule) {
          if (!RegExp(rule).test(value)) {
            throw RangeError(M + objName + '.' + key + (" fails " + rule));
          }
        }
        return value;
      }
      if (/^[A-Z]/.test(type)) {
        if (oo.O === tv) {
          if (eval("value instanceof " + type)) {
            return value;
          }
        }
      }
    }
    throw TypeError(M + objName + '.' + key + (" is type " + tv + " not " + types));
  };
};

Listag = (function() {
  Listag.prototype.C = 'Listag';

  Listag.prototype.toString = function() {
    return '[object Listag]';
  };

  function Listag(config) {
    var M;
    if (config == null) {
      config = {};
    }
    M = '/listag/src/Listag.litcoffee Listag()\n  ';
    oo.define(this, oo._, {}, 'hid');
    this.total = {};
    this.head = {};
    this.tail = {};
    this[oo._]._nodes = {};
    if ('Listag' === this.C) {
      oo.lock(this);
    }
  }

  Listag.prototype.browse = function(config) {
    var M, aToZtags, j, k, len, len1, len2, m, maxId, maxType, meta, node, out, ref, row, t, v;
    if (config == null) {
      config = {};
    }
    M = '/listag/src/Listag.litcoffee Listag::browse()\n  ';
    v = oo.vObject(M, 'config', config);
    v('format <string ^text|array$>', 'text');
    config.tags = oo.vArray(M + 'config.tags', config.tags, "<[string " + TAG_RULE + "]>", []);
    if (!this.total.node) {
      if ('array' === config.format) {
        return [];
      } else {
        return '[empty]';
      }
    }
    ref = config.tags.length ? summarizeAndFilterNodes(this.head.node, config.tags) : summarizeNodes(this.head.node), meta = ref[0], maxId = ref[1], maxType = ref[2], aToZtags = ref[3];
    if ('array' === config.format) {
      return meta;
    }
    row = oo.pad('id', maxId + 2, '.') + oo.pad('type', maxType, '.');
    for (j = 0, len = aToZtags.length; j < len; j++) {
      t = aToZtags[j];
      if ('node' !== t) {
        row += '..' + t;
      }
    }
    out = [row];
    for (k = 0, len1 = meta.length; k < len1; k++) {
      node = meta[k];
      row = oo.pad(node.id, maxId) + '  ' + oo.pad(node.type, maxType);
      for (m = 0, len2 = aToZtags.length; m < len2; m++) {
        t = aToZtags[m];
        if ('node' !== t) {
          row += '  ' + oo.pad(node.tags[t] || ' ', t.length);
        }
      }
      out.push(row);
    }
    return out.join('\n');
  };

  Listag.prototype.read = function(id) {
    var M, node;
    M = '/listag/src/Listag.litcoffee Listag::read()\n  ';
    node = this[oo._]._nodes[id];
    if (oo.isU(node)) {
      oo.vArg(M, id, "id <string " + ID_RULE + ">");
      throw RangeError(M + ("the node with id '" + id + "' does not exist"));
    }
    return node.cargo;
  };

  Listag.prototype.edit = function(id, config) {
    var M, i, j, k, len, len1, nextNode, node, prevNode, ref, ref1, tag, tmp, v;
    if (config == null) {
      config = {};
    }
    M = '/listag/src/Listag.litcoffee Listag::edit()\n  ';
    node = this[oo._]._nodes[id];
    if (oo.isU(node)) {
      oo.vArg(M, id, "id <string " + ID_RULE + ">");
      throw RangeError(M + ("the node with id '" + id + "' does not exist"));
    }
    v = oo.vObject(M, 'config', config);
    if (config.tags) {
      oo.vArray(M + 'config.tags', config.tags, "<[string " + TAG_RULE + "]>");
      tmp = {};
      ref = config.tags;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        tag = ref[i];
        if ('node' === tag) {
          throw RangeError(M + ("config.tags[" + i + "] is the special tag 'node'"));
        }
        if (!oo.isU(tmp[tag])) {
          throw RangeError(M + ("config.tags[" + i + "] is a duplicate of config.tags[" + tmp[tag] + "]"));
        }
        tmp[tag] = i;
      }
    }
    if (0 <= Object.keys(config).indexOf('cargo')) {
      node.cargo = config.cargo;
    }
    if (config.tags) {
      for (tag in node.next) {
        if ('node' === tag || 0 <= config.tags.indexOf(tag)) {
          continue;
        }
        if (--this.total[tag]) {
          if (!node.previous[tag]) {
            this.head[tag] = node.next[tag];
          }
          if (!node.next[tag]) {
            this.tail[tag] = node.previous[tag];
          }
        } else {
          delete this.total[tag];
          delete this.head[tag];
          delete this.tail[tag];
        }
        if (node.previous[tag]) {
          node.previous[tag].next[tag] = node.next[tag];
        }
        if (node.next[tag]) {
          node.next[tag].previous[tag] = node.previous[tag];
        }
        delete node.previous[tag];
        delete node.next[tag];
      }
      ref1 = config.tags;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        tag = ref1[k];
        if (!oo.isU(node.next[tag])) {
          continue;
        }
        if (!this.total[tag]) {
          this.total[tag] = 1;
          this.head[tag] = node;
          this.tail[tag] = node;
          node.previous[tag] = null;
          node.next[tag] = null;
        } else {
          this.total[tag]++;
          prevNode = node.previous.node;
          while (prevNode) {
            if (oo.isU(nextNode = prevNode.next[tag])) {
              prevNode = prevNode.previous.node;
              continue;
            }
            prevNode.next[tag] = node;
            node.previous[tag] = prevNode;
            node.next[tag] = nextNode;
            if (nextNode) {
              nextNode.previous[tag] = node;
            } else {
              this.tail[tag] = node;
            }
            break;
          }
          if (!node.previous[tag]) {
            node.previous[tag] = null;
            this.head[tag] = node;
            nextNode = node.next.node;
            while (nextNode) {
              if (oo.isU(prevNode = nextNode.previous[tag])) {
                nextNode = nextNode.next.node;
                continue;
              }
              nextNode.previous[tag] = node;
              node.next[tag] = nextNode;
              break;
            }
          }
        }
      }
    }
    return void 0;
  };

  Listag.prototype.add = function(cargo, id, tags) {
    var M, i, j, k, len, len1, node, tag, tmp;
    if (tags == null) {
      tags = [];
    }
    M = '/listag/src/Listag.litcoffee Listag::add()\n  ';
    id = id || oo.uid();
    oo.vArg(M, id, "id <string " + ID_RULE + ">");
    if (this[oo._]._nodes[id]) {
      throw RangeError(M + ("a node with id '" + id + "' already exists"));
    }
    oo.vArray(M + 'argument tags', tags, "<[string " + TAG_RULE + "]>");
    tmp = {};
    for (i = j = 0, len = tags.length; j < len; i = ++j) {
      tag = tags[i];
      if ('node' === tag) {
        throw RangeError(M + ("argument tags[" + i + "] is the special tag 'node'"));
      }
      if (!oo.isU(tmp[tag])) {
        throw RangeError(M + ("argument tags[" + i + "] is a duplicate of tags[" + tmp[tag] + "]"));
      }
      tmp[tag] = i;
    }
    tags.push('node');
    node = new Node(cargo, id);
    for (k = 0, len1 = tags.length; k < len1; k++) {
      tag = tags[k];
      node.previous[tag] = this.total[tag] ? this.tail[tag] : null;
      node.next[tag] = null;
      if (this.total[tag]) {
        this.tail[tag].next[tag] = node;
      } else {
        this.head[tag] = node;
        this.total[tag] = 0;
      }
      this.tail[tag] = node;
      this.total[tag]++;
    }
    this[oo._]._nodes[id] = node;
    return id;
  };

  Listag.prototype["delete"] = function(id) {
    var M, j, len, node, ref, tag;
    M = '/listag/src/Listag.litcoffee Listag::delete()\n  ';
    node = this[oo._]._nodes[id];
    if (oo.isU(node)) {
      oo.vArg(M, id, "id <string " + ID_RULE + ">");
      throw RangeError(M + ("the node with id '" + id + "' does not exist"));
    }
    ref = Object.keys(node.next);
    for (j = 0, len = ref.length; j < len; j++) {
      tag = ref[j];
      if (node.previous[tag]) {
        node.previous[tag].next[tag] = node.next[tag];
      }
      if (node.next[tag]) {
        node.next[tag].previous[tag] = node.previous[tag];
      }
      if (--this.total[tag]) {
        if (!node.previous[tag]) {
          this.head[tag] = node.next[tag];
        }
        if (!node.next[tag]) {
          this.tail[tag] = node.previous[tag];
        }
      } else {
        delete this.total[tag];
        delete this.head[tag];
        delete this.tail[tag];
      }
      delete this[oo._]._nodes[id];
    }
    return void 0;
  };

  return Listag;

})();

ID_RULE = '^[a-z]\\w{1,23}$';

TAG_RULE = '^[a-z]\\w{1,23}$';

removeTag = function(listag, tag) {
  var M, nextNode, node;
  M = '/listag/src/Listag.litcoffee removeTag()\n  ';
  if ('node' === tag) {
    return;
  }
  node = listag.head[tag];
  while (node) {
    nextNode = node.next[tag];
    delete node.previous[tag];
    delete node.next[tag];
    node = nextNode;
  }
  delete listag.total[tag];
  delete listag.head[tag];
  delete listag.tail[tag];
  return void 0;
};

summarizeNodes = function(node) {
  var M, aToZtags, maxId, maxType, meta, metaTags, tag, type;
  M = '/listag/src/Listag.litcoffee summarizeNodes()\n  ';
  meta = [];
  maxId = 2;
  maxType = 4;
  aToZtags = {};
  while (node) {
    metaTags = {};
    for (tag in node.next) {
      metaTags[tag] = 'x';
      aToZtags[tag] = 1;
    }
    type = oo.type(node.cargo);
    meta.push({
      id: node.id,
      tags: metaTags,
      type: type
    });
    maxId = Math.max(maxId, node.id.length);
    maxType = Math.max(maxType, type.length);
    node = node.next.node;
  }
  return [meta, maxId, maxType, Object.keys(aToZtags).sort()];
};

summarizeAndFilterNodes = function(node, tags) {
  var M, aToZtags, j, len, maxId, maxType, meta, metaTags, passesFilter, tag, tagFilters, type;
  M = '/listag/src/Listag.litcoffee summarizeAndFilterNodes()\n  ';
  tagFilters = {};
  for (j = 0, len = tags.length; j < len; j++) {
    tag = tags[j];
    tagFilters[tag] = 1;
  }
  meta = [];
  maxId = 2;
  maxType = 4;
  aToZtags = {};
  while (node) {
    passesFilter = false;
    metaTags = {};
    for (tag in node.next) {
      metaTags[tag] = 'x';
      if (tagFilters[tag]) {
        passesFilter = true;
      }
    }
    if (passesFilter) {
      type = oo.type(node.cargo);
      meta.push({
        id: node.id,
        tags: metaTags,
        type: type
      });
      maxId = Math.max(maxId, node.id.length);
      maxType = Math.max(maxType, type.length);
      for (tag in node.next) {
        aToZtags[tag] = 1;
      }
    }
    node = node.next.node;
  }
  return [meta, maxId, maxType, Object.keys(aToZtags).sort()];
};

Node = (function() {
  Node.prototype.C = 'Node';

  Node.prototype.toString = function() {
    return '[object Node]';
  };

  function Node(cargo, id) {
    var M;
    M = '/listag/src/Node.litcoffee Node()\n  ';
    this.previous = {};
    this.next = {};
    this.id = id;
    this.cargo = cargo;
  }

  return Node;

})();

Tudor = (function() {
  Tudor.prototype.I = 'Tudor';

  Tudor.prototype.toString = function() {
    return "[object " + I + "]";
  };

  Tudor.prototype.articles = [];

  function Tudor(opt) {
    this.opt = opt != null ? opt : {};
    this["do"] = bind(this["do"], this);
    switch (this.opt.format) {
      case 'html':
        this.pageHead = function(summary) {
          return "<style>\n  body     { font-family: sans-serif; }\n  a        { outline: 0; }\n  b        { display: inline-block; width: .7em }\n\n  b.pass              { color: #393 }\n  b.fail              { color: #bbb }\n  article.fail b.pass { color: #bbb }\n  section.fail b.pass { color: #bbb }\n\n  pre      { padding: .5em; margin: .2em 0; border-radius: 4px; }\n  pre.fn   { background-color: #fde }\n  pre.pass { background-color: #cfc }\n  pre.fail { background-color: #d8e0e8 }\n\n  article  { margin-bottom: .5rem }\n  article h2 { padding-left:.5rem; margin:0; font-weight:normal }\n  article.pass { border-left: 5px solid #9c9 }\n  article.fail { border-left: 5px solid #9bf }\n  article.fail h2 { margin-bottom: .5rem }\n  article.pass >div { display: none }\n\n  section  { margin-bottom: .5rem }\n  section h3   { padding-left: .5rem; margin: 0; }\n  section.pass { border-left: 3px solid #9c9 }\n  section.fail { border-left: 3px solid #9bf }\n  section.fail h3 { margin-bottom: .5rem }\n  section.pass >div { display: none }\n\n  article.fail section.pass { border-left-color: #ccc }\n\n  div      { padding-left: .5em; }\n  div.fail { border-left: 3px solid #9bf; font-size: .8rem }\n  div h4   { margin: 0 }\n  div h4 { font: normal .8rem/1.2rem monaco, monospace }\n  div.fail, div.fail h4 { margin: .5rem 0 }\n\n</style>\n<h4><a href=\"#end\" id=\"top\">\u2b07</a>  " + summary + "</h4>";
        };
        this.pageFoot = function(summary) {
          return "<h4><a href=\"#top\" id=\"end\">\u2b06</a>  " + summary + "</h4>\n<script>\n  document.title='" + (summary.replace(/<\/?[^>]+>/g, '')) + "';\n</script>";
        };
        this.articleHead = function(heading, fail) {
          return ("<article class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h2>" + (fail ? this.cross : this.tick) + heading + "</h2><div>");
        };
        this.articleFoot = '</div></article>';
        this.sectionHead = function(heading, fail) {
          return ("<section class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h3>" + (fail ? this.cross : this.tick) + heading + "</h3><div>");
        };
        this.sectionFoot = '</div></section>';
        this.jobFormat = function(heading, result) {
          return ("<div class=\"" + (result ? 'fail' : 'pass') + "\">") + ("<h4>" + (result ? this.cross : this.tick) + heading + "</h4>") + ("" + (result ? this.formatError(result) : '')) + "</div>";
        };
        this.tick = '<b class="pass">\u2713</b> ';
        this.cross = '<b class="fail">\u2718</b> ';
        break;
      default:
        this.pageHead = function(summary) {
          return "" + summary;
        };
        this.pageFoot = function(summary) {
          return "\n" + summary;
        };
        this.articleHead = function(heading, fail) {
          return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n===" + (new Array(heading.length).join('=')) + "\n";
        };
        this.articleFoot = '';
        this.sectionHead = function(heading, fail) {
          return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n---" + (new Array(heading.length).join('-')) + "\n";
        };
        this.sectionFoot = '';
        this.jobFormat = function(heading, result) {
          return ((result ? this.cross : this.tick) + " " + heading) + ("" + (result ? '\n' + this.formatError(result) : ''));
        };
        this.jobFoot = '';
        this.tick = '\u2713';
        this.cross = '\u2718';
    }
  }

  Tudor.prototype.add = function(lines) {
    var article, i, line, runner, section;
    article = {
      sections: []
    };
    runner = null;
    section = null;
    if (oo.A !== oo.type(lines)) {
      throw Error("`lines` isn’t an array");
    }
    if (0 === lines.length) {
      throw Error("`lines` has no elements");
    }
    if (oo.S !== oo.type(lines[0])) {
      throw Error("`lines[0]` isn’t a string");
    }
    article.heading = lines.shift();
    i = 0;
    while (i < lines.length) {
      line = lines[i];
      switch (oo.type(line)) {
        case oo.O:
          if (!line.runner) {
            throw new Error("Errant object");
          }
          runner = line.runner;
          break;
        case oo.F:
          section.jobs.push(line);
          break;
        case oo.S:
          if (this.isAssertion(lines[i + 1], lines[i + 2])) {
            if (!section) {
              throw new Error("Cannot add an assertion here");
            }
            section.jobs.push([runner, line, lines[++i], lines[++i]]);
          } else {
            section = {
              heading: line,
              jobs: []
            };
            article.sections.push(section);
          }
      }
      i++;
    }
    return this.articles.push(article);
  };

  Tudor.prototype["do"] = function() {
    var actual, art, artFail, artPass, article, e, error, expect, heading, j, job, k, len, len1, len2, m, mock, mockFail, pge, pgeFail, pgePass, ref, ref1, ref2, result, runner, sec, secFail, secPass, section, summary;
    pge = [];
    mock = [];
    pgePass = pgeFail = mockFail = 0;
    ref = this.articles;
    for (j = 0, len = ref.length; j < len; j++) {
      article = ref[j];
      art = [];
      artPass = artFail = 0;
      ref1 = article.sections;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        section = ref1[k];
        sec = [];
        secPass = secFail = 0;
        ref2 = section.jobs;
        for (m = 0, len2 = ref2.length; m < len2; m++) {
          job = ref2[m];
          switch (oo.type(job)) {
            case oo.F:
              try {
                mock = job.apply(this, mock);
              } catch (_error) {
                e = _error;
                error = e.message;
              }
              if (error) {
                mockFail++;
                secFail++;
                sec.push(this.formatMockModifierError(job, error));
              }
              break;
            case oo.A:
              runner = job[0], heading = job[1], expect = job[2], actual = job[3];
              result = runner(expect, actual, mock);
              if (!result) {
                sec.push(this.jobFormat("" + (this.sanitize(heading))));
                pgePass++;
                artPass++;
                secPass++;
              } else {
                sec.push(this.jobFormat("" + (this.sanitize(heading)), result));
                pgeFail++;
                artFail++;
                secFail++;
              }
          }
        }
        sec.unshift(this.sectionHead("" + (this.sanitize(section.heading)), secFail));
        sec.push(this.sectionFoot);
        art = art.concat(sec);
      }
      art.unshift(this.articleHead("" + (this.sanitize(article.heading)), artFail));
      art.push(this.articleFoot);
      pge = pge.concat(art);
      summary = pgeFail ? this.cross + " FAILED " + pgeFail + "/" + (pgePass + pgeFail) : this.tick + " Passed " + pgePass + "/" + (pgePass + pgeFail);
      if (mockFail) {
        summary = "\n" + this.cross + " (MOCK FAILS)";
      }
    }
    pge.unshift(this.pageHead(summary));
    pge.push(this.pageFoot(summary));
    return pge.join('\n');
  };

  Tudor.prototype.formatError = function(result) {
    switch (result.length + "-" + this.opt.format) {
      case '2-html':
        return result[0] + "\n<pre class=\"fail\">" + (this.sanitize(result[1].message)) + "</pre>";
      case '2-plain':
        return result[0] + "\n" + (this.sanitize(result[1].message));
      case '3-html':
        return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + "</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + "</pre>";
      case '3-plain':
        return (this.sanitize(this.reveal(result[0]))) + "\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2])));
      case '4-html':
        return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + " (" + (oo.type(result[0])) + ")</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + " (" + (oo.type(result[2])) + ")</pre>";
      case '4-plain':
        return (this.sanitize(this.reveal(result[0]))) + " (" + (oo.type(result[0])) + ")\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2]))) + " (" + (oo.type(result[2])) + ")";
      default:
        throw new Error("Cannot process '" + result.length + "-" + this.opt.format + "'");
    }
  };

  Tudor.prototype.formatMockModifierError = function(fn, error) {
    switch (this.opt.format) {
      case 'html':
        return "<pre class=\"fn\">" + (this.sanitize(fn + '')) + "</pre>\n...encountered an exception:\n<pre class=\"fail\">" + (this.sanitize(error)) + "</pre>";
      default:
        return (this.sanitize(fn + '')) + "\n...encountered an exception:\n" + (this.sanitize(error));
    }
  };

  Tudor.prototype.reveal = function(value) {
    return value != null ? value.toString().replace(/^\s+|\s+$/g, function(match) {
      return '\u00b7' + (new Array(match.length)).join('\u00b7');
    }) : void 0;
  };

  Tudor.prototype.sanitize = function(value) {
    switch (this.opt.format) {
      case 'html':
        return value != null ? value.toString().replace(/</g, '&lt;') : void 0;
      default:
        return value;
    }
  };

  Tudor.prototype["throw"] = {
    runner: function(expect, actual, mock) {
      var e, error;
      if (mock == null) {
        mock = [];
      }
      error = false;
      try {
        actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (!error) {
        return [
          'No exception thrown, expected', {
            message: expect
          }
        ];
      } else if (expect !== error.message) {
        return [error.message, 'was thrown, but expected', expect];
      }
    }
  };

  Tudor.prototype.equal = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      if (mock == null) {
        mock = [];
      }
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (expect !== result) {
        if (result + '' === expect + '') {
          return [result, 'was returned, but expected', expect, true];
        } else {
          return [result, 'was returned, but expected', expect];
        }
      }
    }
  };

  Tudor.prototype.is = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      if (mock == null) {
        mock = [];
      }
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (expect !== oo.type(result)) {
        return ["type " + (oo.type(result)), 'was returned, but expected', "type " + expect];
      }
    }
  };

  Tudor.prototype.match = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      if (mock == null) {
        mock = [];
      }
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (oo.F !== typeof expect.test) {
        return [
          '`test()` is not a function', {
            message: expect
          }
        ];
      } else if (!expect.test('' + result)) {
        return ['' + result, 'failed test', expect];
      }
    }
  };

  Tudor.prototype.isAssertion = function(line1, line2) {
    if (oo.F !== oo.type(line2)) {
      return false;
    }
    if ((oo.O === oo.type(line1)) && oo.F === oo.type(line1.runner)) {
      return false;
    }
    return true;
  };

  return Tudor;

})();

tudor = new Tudor({
  format: oo.O === typeof window ? 'html' : 'plain'
});

Listag.runTest = tudor["do"];

tudor.add([
  "01 Listag Constructor", tudor.is, "The class and instance are expected types", function() {
    return [new Listag];
  }, "The Listag class is a function", oo.F, function() {
    return Listag;
  }, "Cannot add a property to the Listag class", oo.U, function() {
    Listag.nope = 123;
    return Listag.nope;
  }, "`new` returns an object", oo.O, function(listag) {
    return listag;
  }, "Cannot add a property to the Listag class’s prototype object", oo.U, function(listag) {
    Listag.prototype.nope = 456;
    return listag.nope;
  }, "Instance properties as expected", "`Listag::_nodes` is a private object", oo.O, function(listag) {
    return listag[oo._]._nodes;
  }, "`Listag::total` is an object", oo.O, function(listag) {
    return listag.total;
  }, "`Listag::head` is an object", oo.O, function(listag) {
    return listag.head;
  }, "`Listag::tail` is an object", oo.O, function(listag) {
    return listag.tail;
  }, tudor.equal, "A listag instance has enumerable properties as expected", '{"total":{},"head":{},"tail":{}}', function(listag) {
    return JSON.stringify(listag);
  }, "`Listag::C` is 'Listag'", 'Listag', function(listag) {
    return listag.C;
  }, "`Listag::toString()` is '[object Listag]'", '[object Listag]', function(listag) {
    return listag + '';
  }, "`Listag::_nodes` is empty", 0, function(listag) {
    return Object.keys(listag[oo._]._nodes).length;
  }, "`Listag::total` is empty", 0, function(listag) {
    return Object.keys(listag.total).length;
  }, "`Listag::head` is empty", 0, function(listag) {
    return Object.keys(listag.head).length;
  }, "`Listag::tail` is empty", 0, function(listag) {
    return Object.keys(listag.tail).length;
  }
]);

tudor.add([
  "02 Listag::add()", tudor.is, "`add()` is a function which returns a string", function() {
    return [new Listag];
  }, "`add()` is a function", oo.F, function(listag) {
    return listag.add;
  }, "`add({x:'the_first'})` returns a string", oo.S, function(listag) {
    return listag.add({
      x: 'the_first'
    });
  }, tudor.equal, "The returned string is the same as the `id` argument", 'passed_an_id_argument', function(listag) {
    return listag.add({
      x: 'the_second'
    }, 'passed_an_id_argument');
  }, "If no `id` argument is passed, an id is generated", true, function(listag) {
    return /^id_[a-zA-Z0-9]{8}$/.test(listag.add({}));
  }, "The `node` argument accepts objects as expected", "A simple object can be recorded", 'simple_object', function(listag) {
    listag.add({
      x: 'simple_object'
    });
    return listag.tail.node.cargo.x;
  }, "A Listag instance can be recorded in itself", 'simple_object', function(listag) {
    listag.add(listag);
    return listag.tail.node.previous.node.cargo.x;
  }, "A Listag instance can be recorded in another Listag instance", 'obj_in_subListag', function(listag) {
    var subListag;
    subListag = new Listag;
    subListag.add({
      x: 'obj_in_subListag'
    });
    listag.add(subListag);
    return listag.tail.node.cargo.tail.node.cargo.x;
  }, "The `id` argument accepts a string as expected", tudor.equal, "Shortest possible id", 11, function(listag) {
    listag.add({
      x: 11
    }, 'aB');
    return listag.tail.node.cargo.x;
  }, "Longest possible id", 22, function(listag) {
    listag.add({
      x: 22
    }, 'abcdefghijklmnopqrst123_');
    return listag.tail.node.cargo.x;
  }, "Can repeat existing id, if case is different", 33, function(listag) {
    listag.add({
      x: 33
    }, 'aBcDeFgHiJkLmNoPqRsT123_');
    return listag.tail.node.cargo.x;
  }, "Can be empty string (id is autogenerated)", 44, function(listag) {
    listag.add({
      x: 44
    }, '');
    return listag.tail.node.cargo.x;
  }, "`id` exceptions", tudor["throw"], "Is boolean", "/listag/src/Listag.litcoffee Listag::add()\n  argument id is type boolean not string", function(listag) {
    return listag.add({}, true);
  }, "Too short", "/listag/src/Listag.litcoffee Listag::add()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.add({}, 'a');
  }, "Too long", "/listag/src/Listag.litcoffee Listag::add()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.add({}, 'aBcDeFgHiJkLmNoPqRsT123_X');
  }, "Underscore is an invalid first character", "/listag/src/Listag.litcoffee Listag::add()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.add({}, '_abc');
  }, "Number is an invalid first character", "/listag/src/Listag.litcoffee Listag::add()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.add({}, '1abc');
  }, "Uppercase is an invalid first character", "/listag/src/Listag.litcoffee Listag::add()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.add({}, 'Abc');
  }, "Must not contain a hyphen", "/listag/src/Listag.litcoffee Listag::add()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.add({}, 'ab-c');
  }, "Must be unique", "/listag/src/Listag.litcoffee Listag::add()\n  a node with id 'the_last' already exists", function(listag) {
    listag.add({}, 'the_last');
    return listag.add({}, 'the_last');
  }, "The `tags` argument accepts an array as expected", tudor.equal, "An empty array", 789, function(listag) {
    listag.add({
      x: 789
    }, 'abc', []);
    return listag.tail.node.cargo.x;
  }, "An array with arbitrary properties", 'leftmost_dog', function(listag) {
    var tags;
    tags = ['dog', 'ok123'];
    tags.thing = 'Unexpected!';
    listag.add({
      x: 'leftmost_dog'
    }, void 0, tags);
    return listag.tail.node.cargo.x;
  }, "Can be mixed-case 'aLL'", 'rightmost_dog', function(listag) {
    listag.add({
      x: 'rightmost_dog'
    }, 'rightmost_dog', ['cat', 'dog', 'aLL']);
    return listag.tail.node.cargo.x;
  }, "Can be undefined", 'second_from_last', function(listag) {
    listag.add({
      x: 'second_from_last'
    }, 'ghi', void 0);
    return listag.tail.node.cargo.x;
  }, "Can be null", 'the_last', function(listag) {
    listag.add({
      x: 'the_last'
    }, 'klm', null);
    return listag.tail.node.cargo.x;
  }, "`tags` exceptions", tudor["throw"], "A string", "/listag/src/Listag.litcoffee Listag::add()\n  argument tags is type string not array", function(listag) {
    return listag.add({}, void 0, 'nope');
  }, "Contains a number", "/listag/src/Listag.litcoffee Listag::add()\n  argument tags[2] is type number not string", function(listag) {
    return listag.add({}, void 0, ['ok', 'fine', 123456, 'uh_oh']);
  }, "Contains an empty string", "/listag/src/Listag.litcoffee Listag::add()\n  argument tags[3] fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.add({}, void 0, ['no', 'empties', 'allowed', '']);
  }, "Contains a string starting with a digit", "/listag/src/Listag.litcoffee Listag::add()\n  argument tags[0] fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.add({}, void 0, ['123abc', 'nope']);
  }, "Contains a string starting with an uppercase letter", "/listag/src/Listag.litcoffee Listag::add()\n  argument tags[3] fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.add({}, void 0, ['must', 'be', 'only', 'Lowercase']);
  }, "Contains the special string 'node'", "/listag/src/Listag.litcoffee Listag::add()\n  argument tags[0] is the special tag 'node'", function(listag) {
    return listag.add({}, void 0, ['node', 'is', 'reserved']);
  }, "Contains duplicate tags at indices 1 and 3", "/listag/src/Listag.litcoffee Listag::add()\n  argument tags[3] is a duplicate of tags[1]", function(listag) {
    return listag.add({}, void 0, ['here', 'again', 'there', 'again']);
  }, "Contains many duplicate tags, including indices 0 and 2", "/listag/src/Listag.litcoffee Listag::add()\n  argument tags[2] is a duplicate of tags[0]", function(listag) {
    return listag.add({}, void 0, ['aa', 'bb', 'aa', 'aa', 'bb']);
  }, "'node' `total`, `head`, `tail`, `previous` and `next` as expected", tudor.equal, "16 nodes created during the '02 Listag::add()' test", 16, function(listag) {
    return listag.total.node;
  }, "5 tags created during the '02 Listag::add()' test", 5, function(listag) {
    return Object.keys(listag.total).length;
  }, "Traversing rightward from `head` takes 16 steps", 16, function(listag) {
    var i, node;
    i = 0;
    node = listag.head.node;
    while (node) {
      i++;
      node = node.next.node;
    }
    return i;
  }, "Traversing leftward from `tail` takes 16 steps", 16, function(listag) {
    var i, node;
    i = 0;
    node = listag.tail.node;
    while (node) {
      i++;
      node = node.previous.node;
    }
    return i;
  }, "Traversing rightward from `aB` takes 10 steps", 10, function(listag) {
    var i, node;
    i = 0;
    node = listag[oo._]._nodes.aB;
    while (node) {
      i++;
      node = node.next.node;
    }
    return i;
  }, "The leftmost node is 'the_first'", 'the_first', function(listag) {
    return listag.head.node.cargo.x;
  }, "The rightmost node is 'the_last'", 'the_last', function(listag) {
    return listag.tail.node.cargo.x;
  }, "The leftmost node’s leftward node is null", null, function(listag) {
    return listag.head.node.previous.node;
  }, "The rightmost node’s rightward node is null", null, function(listag) {
    return listag.tail.node.next.node;
  }, "The leftmost node’s `next.node` is 'the_second'", 'the_second', function(listag) {
    return listag.head.node.next.node.cargo.x;
  }, "The rightmost node’s `previous.node` is 'second_from_last'", 'second_from_last', function(listag) {
    return listag.tail.node.previous.node.cargo.x;
  }, "'dog' `total`, `head`, `tail`, `previous` and `next` as expected", "2 'dog' nodes created during the '02 Listag::add()' test", 2, function(listag) {
    return listag.total.dog;
  }, "Traversing dogs rightward from the leftmost dog takes 2 steps", 2, function(listag) {
    var i, node;
    i = 0;
    node = listag.head.dog;
    while (node) {
      i++;
      node = node.next.dog;
    }
    return i;
  }, "Traversing dogs leftward from the rightmost dog takes 2 steps", 2, function(listag) {
    var i, node;
    i = 0;
    node = listag.tail.dog;
    while (node) {
      i++;
      node = node.previous.dog;
    }
    return i;
  }, "Traversing dogs rightward from `rightmost_dog` takes 1 steps", 1, function(listag) {
    var i, node;
    i = 0;
    node = listag[oo._]._nodes.rightmost_dog;
    oo;
    while (node) {
      i++;
      node = node.next.dog;
    }
    return i;
  }, "The leftmost dog node is 'leftmost_dog'", 'leftmost_dog', function(listag) {
    return listag.head.dog.cargo.x;
  }, "The rightmost dog node is 'rightmost_dog'", 'rightmost_dog', function(listag) {
    return listag.tail.dog.cargo.x;
  }, "The leftmost dog’s leftward dog is null", null, function(listag) {
    return listag.head.dog.previous.dog;
  }, "The rightmost dog’s rightward dog is null", null, function(listag) {
    return listag.tail.dog.next.dog;
  }, "The leftmost dog’s `next.dog` is 'rightmost_dog'", 'rightmost_dog', function(listag) {
    return listag.head.dog.next.dog.cargo.x;
  }, "The rightmost dog’s `previous.dog` is 'leftmost_dog'", 'leftmost_dog', function(listag) {
    return listag.tail.dog.previous.dog.cargo.x;
  }
]);

tudor.add([
  "03 Listag::read()", tudor.is, "`read()` is a function which may return any kind of value", function() {
    return [new Listag];
  }, "`read()` is a function", oo.F, function(listag) {
    return listag.read;
  }, "`read('the_first')` returns a Date with the correct type", 'date', function(listag) {
    listag.add(new Date, 'the_first');
    return listag.read('the_first');
  }, tudor.equal, "A returned number is the same as the `cargo` argument passed to `add()`", 4.56, function(listag) {
    listag.add(4.56, 'the_second');
    return listag.read('the_second');
  }, "A returned object is the same as the `cargo` argument passed to `add()`", true, function(listag) {
    var cargo;
    cargo = {};
    listag.add(cargo, 'the_third');
    return cargo === listag.read('the_third');
  }, "The `id` argument accepts a string as expected", "Shortest possible id", 11, function(listag) {
    listag.add({
      x: 11
    }, 'aB');
    return listag.read('aB').x;
  }, "Longest possible id", 22, function(listag) {
    listag.add({
      x: 22
    }, 'abcdefghijklMNOPQRST123_');
    return listag.read('abcdefghijklMNOPQRST123_').x;
  }, "An autogenerated id (the `add()` `id` argument can be `null`)", 44, function(listag) {
    var id;
    id = listag.add({
      x: 44
    }, null);
    return listag.read(id).x;
  }, "`id` exceptions", tudor["throw"], "Is boolean", "/listag/src/Listag.litcoffee Listag::read()\n  argument id is type boolean not string", function(listag) {
    return listag.read(true);
  }, "Too short", "/listag/src/Listag.litcoffee Listag::read()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.read('a');
  }, "Too long", "/listag/src/Listag.litcoffee Listag::read()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.read('aBcDeFgHiJkLmNoPqRsT123_X');
  }, "Underscore is an invalid first character", "/listag/src/Listag.litcoffee Listag::read()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.read('_abc');
  }, "Number is an invalid first character", "/listag/src/Listag.litcoffee Listag::read()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.read('1abc');
  }, "Uppercase is an invalid first character", "/listag/src/Listag.litcoffee Listag::read()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.read('Abc');
  }, "Must not contain a hyphen", "/listag/src/Listag.litcoffee Listag::read()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.read('ab-c');
  }, "Must exist", "/listag/src/Listag.litcoffee Listag::read()\n  the node with id 'non_existant' does not exist", function(listag) {
    return listag.read('non_existant');
  }
]);

tudor.add([
  "04 Listag::delete()", tudor.is, "`delete()` is a function which does not return anything", function() {
    return [new Listag];
  }, "`delete()` is a function", oo.F, function(listag) {
    return listag["delete"];
  }, "`delete()` is not writable", oo.F, function(listag) {
    listag["delete"] = 123;
    return listag["delete"];
  }, "`delete()` is not configurable", oo.F, function(listag) {
    var e;
    try {
      Object.defineProperty(listag, 'delete', {
        writable: true
      });
    } catch (_error) {
      e = _error;
    }
    listag["delete"] = 123;
    return listag["delete"];
  }, "`delete('the_first')` returns `undefined`", oo.U, function(listag) {
    listag.add(new Date, 'the_first');
    return listag["delete"]('the_first');
  }, tudor.equal, "After deletion, `total.node` is zero", 0, function(listag) {
    return Object.keys(listag.total).length;
  }, "The `id` argument accepts a string as expected", "Shortest possible id", 0, function(listag) {
    listag.add({}, 'a1');
    listag["delete"]('a1');
    return Object.keys(listag.total).length;
  }, "Longest possible id", 0, function(listag) {
    listag.add({}, 'abcdefghijklMNOPQRST123_');
    listag["delete"]('abcdefghijklMNOPQRST123_');
    return Object.keys(listag.total).length;
  }, "An autogenerated id", 0, function(listag) {
    var id;
    id = listag.add({});
    listag["delete"](id);
    return Object.keys(listag.total).length;
  }, "`id` exceptions", tudor["throw"], "Is boolean", "/listag/src/Listag.litcoffee Listag::delete()\n  argument id is type boolean not string", function(listag) {
    return listag["delete"](true);
  }, "Too short", "/listag/src/Listag.litcoffee Listag::delete()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag["delete"]('a');
  }, "Too long", "/listag/src/Listag.litcoffee Listag::delete()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag["delete"]('aBcDeFgHiJkLmNoPqRsT123_X');
  }, "Underscore is an invalid first character", "/listag/src/Listag.litcoffee Listag::delete()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag["delete"]('_abc');
  }, "Number is an invalid first character", "/listag/src/Listag.litcoffee Listag::delete()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag["delete"]('1abc');
  }, "Uppercase is an invalid first character", "/listag/src/Listag.litcoffee Listag::delete()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag["delete"]('Abc');
  }, "Must not contain a hyphen", "/listag/src/Listag.litcoffee Listag::delete()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag["delete"]('ab-c');
  }, "Must exist", "/listag/src/Listag.litcoffee Listag::delete()\n  the node with id 'non_existant' does not exist", function(listag) {
    return listag["delete"]('non_existant');
  }
]);

tudor.add([
  "05 Listag::browse()", tudor.is, "`browse()` is a function which returns a string or an array", function() {
    return [new Listag];
  }, "`browse()` is a function", oo.F, function(listag) {
    return listag.browse;
  }, "`browse()` is not writable", oo.F, function(listag) {
    listag.browse = 123;
    return listag.browse;
  }, "`browse()` is not configurable", oo.F, function(listag) {
    var e;
    try {
      Object.defineProperty(listag, 'browse', {
        writable: true
      });
    } catch (_error) {
      e = _error;
    }
    listag.browse = 'nope';
    return listag.browse;
  }, "`browse()` cannot be replaced by another method using `prototype`", oo.S, function() {
    Listag.prototype.browse = function() {
      return false;
    };
    return (new Listag).browse();
  }, "`browse()` cannot be replaced by another method using direct-access", oo.S, function(listag) {
    listag.browse = function() {
      return [];
    };
    return listag.browse();
  }, "`browse()` returns a string", oo.S, function(listag) {
    return listag.browse();
  }, "`browse({format:'array'})` returns an array", oo.A, function(listag) {
    return listag.browse({
      format: 'array'
    });
  }, tudor.equal, "For an empty Listag instance, `browse()` returns the string '[empty]'", '[empty]', function(listag) {
    return listag.browse();
  }, "If empty, `browse({format:'array'})` returns an empty array", 0, function(listag) {
    return (listag.browse({
      format: 'array'
    })).length;
  }, "For a populated Listag instance, `browse()` returns a table, as a string", "id.......type.....aa..bbbb\nthe_1st  boolean  x   x   ", function(listag) {
    listag.add(true, 'the_1st', ['aa', 'bbbb']);
    return listag.browse();
  }, "The `config` argument accepts an object as expected", "Empty object", "id..........type.....aa..bbbb..ccc\nthe_1st     boolean  x   x        \nthe_second  number       x     x  \nthird       array                 \nfourth      regexp             x  ", function(listag) {
    listag.add(222, 'the_second', ['bbbb', 'ccc']);
    listag.add([3], 'third');
    listag.add(/4/, 'fourth', ['ccc']);
    return listag.browse({});
  }, "Can contain arbitrary properties", "id..........type.....aa..bbbb..ccc\nthe_1st     boolean  x   x        \nthe_second  number       x     x  \nthird       array                 \nfourth      regexp             x  ", function(listag) {
    return listag.browse({
      a: 1,
      '-!•': 'ok'
    });
  }, "Can be `null`", "id..........type.....aa..bbbb..ccc\nthe_1st     boolean  x   x        \nthe_second  number       x     x  \nthird       array                 \nfourth      regexp             x  ", function(listag) {
    return listag.browse(null);
  }, "Can be `undefined`", "id..........type.....aa..bbbb..ccc\nthe_1st     boolean  x   x        \nthe_second  number       x     x  \nthird       array                 \nfourth      regexp             x  ", function(listag) {
    return listag.browse(void 0);
  }, "`config` exceptions", tudor["throw"], "Is boolean", "/listag/src/Listag.litcoffee Listag::browse()\n  config is type boolean not object", function(listag) {
    return listag.browse(true);
  }, "Is an array", "/listag/src/Listag.litcoffee Listag::browse()\n  config is type array not object", function(listag) {
    return listag.browse([1, 2, 3]);
  }, "`config.format` usage", tudor.equal, "The string 'text'", "id..........type....bbbb..ccc\nthe_second  number  x     x  \nthird       array            \nfourth      regexp        x  ", function(listag) {
    listag["delete"]('the_1st');
    return listag.browse({
      format: 'text'
    });
  }, "The string 'array'", "{\"id\":\"the_second\",\"tags\":{\"bbbb\":\"x\",\"ccc\":\"x\",\"node\":\"x\"},\"type\":\"number\"}\n{\"id\":\"third\",\"tags\":{\"node\":\"x\"},\"type\":\"array\"}\n{\"id\":\"fourth\",\"tags\":{\"ccc\":\"x\",\"node\":\"x\"},\"type\":\"regexp\"}", function(listag) {
    var node, nodes, out;
    nodes = listag.browse({
      format: 'array'
    });
    out = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = nodes.length; j < len; j++) {
        node = nodes[j];
        results.push(JSON.stringify(node));
      }
      return results;
    })();
    return out.join('\n');
  }, "`config.format` exceptions", tudor["throw"], "Is number", "/listag/src/Listag.litcoffee Listag::browse()\n  config.format is type number not string", function(listag) {
    return listag.browse({
      format: 123
    });
  }, "Is RegExp", "/listag/src/Listag.litcoffee Listag::browse()\n  config.format is type regexp not string", function(listag) {
    return listag.browse({
      format: /text/
    });
  }, "Is empty string", "/listag/src/Listag.litcoffee Listag::browse()\n  config.format fails ^text|array$", function(listag) {
    return listag.browse({
      format: ''
    });
  }, "Is an invalid string", "/listag/src/Listag.litcoffee Listag::browse()\n  config.format fails ^text|array$", function(listag) {
    return listag.browse({
      format: 'Text'
    });
  }, "`config.tags` usage", tudor.equal, "An empty array", "id..........type....bbbb..ccc\nthe_second  number  x     x  \nthird       array            \nfourth      regexp        x  ", function(listag) {
    return listag.browse({
      tags: []
    });
  }, "A single tag, text format", "id..........type....bbbb..ccc\nthe_second  number  x     x  \nfourth      regexp        x  ", function(listag) {
    listag.add(true, 'the_1st', ['aa', 'bbbb']);
    return listag.browse({
      tags: ['ccc']
    });
  }, "A single tag, array format", "{\"id\":\"the_second\",\"tags\":{\"bbbb\":\"x\",\"ccc\":\"x\",\"node\":\"x\"},\"type\":\"number\"}\n{\"id\":\"fourth\",\"tags\":{\"ccc\":\"x\",\"node\":\"x\"},\"type\":\"regexp\"}", function(listag) {
    var node, nodes, out;
    nodes = listag.browse({
      tags: ['ccc'],
      format: 'array'
    });
    out = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = nodes.length; j < len; j++) {
        node = nodes[j];
        results.push(JSON.stringify(node));
      }
      return results;
    })();
    return out.join('\n');
  }, "Two tags, text format", "id..........type.....aa..bbbb..ccc\nthe_second  number       x     x  \nfourth      regexp             x  \nthe_1st     boolean  x   x        ", function(listag) {
    return listag.browse({
      tags: ['aa', 'ccc']
    });
  }, "Two tags, array format", "{\"id\":\"the_second\",\"tags\":{\"bbbb\":\"x\",\"ccc\":\"x\",\"node\":\"x\"},\"type\":\"number\"}\n{\"id\":\"fourth\",\"tags\":{\"ccc\":\"x\",\"node\":\"x\"},\"type\":\"regexp\"}\n{\"id\":\"the_1st\",\"tags\":{\"aa\":\"x\",\"bbbb\":\"x\",\"node\":\"x\"},\"type\":\"boolean\"}", function(listag) {
    var node, nodes, out;
    nodes = listag.browse({
      tags: ['aa', 'ccc'],
      format: 'array'
    });
    out = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = nodes.length; j < len; j++) {
        node = nodes[j];
        results.push(JSON.stringify(node));
      }
      return results;
    })();
    return out.join('\n');
  }, "`config.tags` exceptions", tudor["throw"], "Is number", "/listag/src/Listag.litcoffee Listag::browse()\n  config.tags is type number not array", function(listag) {
    return listag.browse({
      tags: 123
    });
  }
]);

tudor.add([
  "06 Listag::edit()", tudor.is, "`edit()` is a function which returns a string", function() {
    return [new Listag];
  }, "`edit()` is a function", oo.F, function(listag) {
    return listag.edit;
  }, "`edit()` is not writable", oo.F, function(listag) {
    listag.edit = 123;
    return listag.edit;
  }, "`edit()` is not configurable", oo.F, function(listag) {
    var e;
    try {
      Object.defineProperty(listag, 'edit', {
        writable: true
      });
    } catch (_error) {
      e = _error;
    }
    listag.edit = 'nope';
    return listag.edit;
  }, "`edit()` cannot be replaced by another method using `prototype`", oo.U, function() {
    var listag;
    Listag.prototype.edit = function() {
      return 123;
    };
    listag = new Listag;
    listag.add(new Date, 'the_first');
    return listag.edit('the_first');
  }, "`edit()` cannot be replaced by another method using direct-access", oo.U, function(listag) {
    listag.edit = function() {
      return [];
    };
    listag.add(22, 'the_first');
    return listag.edit('the_first');
  }, "`edit('the_first')` returns `undefined`", oo.U, function(listag) {
    return listag.edit('the_first');
  }, "The `config` argument can be an empty object", oo.U, function(listag) {
    return listag.edit('the_first', {});
  }, "`config.cargo` replaces the node’s current cargo", tudor.equal, "`config.cargo` can be changed from a number to boolean `false`", false, function(listag) {
    listag.edit('the_first', {
      cargo: false
    });
    return listag.read('the_first');
  }, "`config.cargo` can be changed from boolean `false` to the number `123`", 123, function(listag) {
    listag.edit('the_first', {
      cargo: 123
    });
    return listag.read('the_first');
  }, "If `config.cargo` is not set, it remains `123`", 123, function(listag) {
    listag.edit('the_first', {});
    return listag.read('the_first');
  }, "`config.cargo` can be changed to `undefined`", "id.........type.....\nthe_first  undefined", function(listag) {
    listag.edit('the_first', {
      cargo: void 0
    });
    return listag.browse();
  }, "`id` exceptions", tudor["throw"], "Is boolean", "/listag/src/Listag.litcoffee Listag::edit()\n  argument id is type boolean not string", function(listag) {
    return listag.edit(true);
  }, "Too short", "/listag/src/Listag.litcoffee Listag::edit()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.edit('a');
  }, "Too long", "/listag/src/Listag.litcoffee Listag::edit()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.edit('aBcDeFgHiJkLmNoPqRsT123_X');
  }, "Underscore is an invalid first character", "/listag/src/Listag.litcoffee Listag::edit()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.edit('_abc');
  }, "Number is an invalid first character", "/listag/src/Listag.litcoffee Listag::edit()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.edit('1abc');
  }, "Uppercase is an invalid first character", "/listag/src/Listag.litcoffee Listag::edit()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.edit('Abc');
  }, "Must not contain a hyphen", "/listag/src/Listag.litcoffee Listag::edit()\n  argument id fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.edit('ab-c');
  }, "Does not exist", "/listag/src/Listag.litcoffee Listag::edit()\n  the node with id 'non_existant' does not exist", function(listag) {
    return listag.edit('non_existant');
  }, "`config.tags` accepts an array as expected", tudor.equal, "Straightforward addition of a single tag", "id.........type.......aa\nthe_first  undefined  x \nnode:1 aa:1 bb:0 cc:0", function(listag) {
    listag.edit('the_first', {
      tags: ['aa']
    });
    return listag.browse() + '\n' + 'node:' + listag.total.node + ' aa:' + (listag.total.aa || 0) + ' bb:' + (listag.total.bb || 0) + ' cc:' + (listag.total.cc || 0);
  }, "Without a `config.tags` property, nothing changes", "id.........type.......aa\nthe_first  undefined  x \nnode:1 aa:1 bb:0 cc:0", function(listag) {
    listag.edit('the_first', {});
    return listag.browse() + '\n' + 'node:' + listag.total.node + ' aa:' + (listag.total.aa || 0) + ' bb:' + (listag.total.bb || 0) + ' cc:' + (listag.total.cc || 0);
  }, "With an empty `config.tags` array, no tags remain", "id.........type.....\nthe_first  undefined\nnode:1 aa:0 bb:0 cc:0", function(listag) {
    listag.edit('the_first', {
      tags: []
    });
    return listag.browse() + '\n' + 'node:' + listag.total.node + ' aa:' + (listag.total.aa || 0) + ' bb:' + (listag.total.bb || 0) + ' cc:' + (listag.total.cc || 0);
  }, "Two tags can be added at once (also, changing cargo during edit)", "id.........type....aa..bb\nthe_first  number  x   x \nnode:1 aa:1 bb:1 cc:0\n\nhead.node: the_first\ntail.node: the_first\nhead.aa:   the_first\ntail.aa:   the_first\nhead.bb:   the_first\ntail.bb:   the_first\nhead.cc:   undefined\ntail.cc:   undefined\n\nhead.node.next.aa:     null\ntail.node.next.aa:     null\nhead.node.previous.aa: null\ntail.node.previous.aa: null\nhead.node.next.bb:     null\ntail.node.next.bb:     null\nhead.node.previous.bb: null\ntail.node.previous.bb: null\nhead.node.next.cc:     undefined\ntail.node.next.cc:     undefined\nhead.node.previous.cc: undefined\ntail.node.previous.cc: undefined" + '\n', function(listag) {
    var summary;
    listag.edit('the_first', {
      cargo: 1,
      tags: ['aa', 'bb']
    });
    summary = function(node) {
      return (node ? node.id : node) + '\n';
    };
    return listag.browse() + '\n' + 'node:' + listag.total.node + ' aa:' + (listag.total.aa || 0) + ' bb:' + (listag.total.bb || 0) + ' cc:' + (listag.total.cc || 0) + '\n\n' + 'head.node: ' + summary(listag.head.node) + 'tail.node: ' + summary(listag.tail.node) + 'head.aa:   ' + summary(listag.head.aa) + 'tail.aa:   ' + summary(listag.tail.aa) + 'head.bb:   ' + summary(listag.head.bb) + 'tail.bb:   ' + summary(listag.tail.bb) + 'head.cc:   ' + summary(listag.head.cc) + 'tail.cc:   ' + summary(listag.tail.cc) + '\n' + 'head.node.next.aa:     ' + summary(listag.head.node.next.aa) + 'tail.node.next.aa:     ' + summary(listag.tail.node.next.aa) + 'head.node.previous.aa: ' + summary(listag.head.node.previous.aa) + 'tail.node.previous.aa: ' + summary(listag.tail.node.previous.aa) + 'head.node.next.bb:     ' + summary(listag.head.node.next.bb) + 'tail.node.next.bb:     ' + summary(listag.tail.node.next.bb) + 'head.node.previous.bb: ' + summary(listag.head.node.previous.bb) + 'tail.node.previous.bb: ' + summary(listag.tail.node.previous.bb) + 'head.node.next.cc:     ' + summary(listag.head.node.next.cc) + 'tail.node.next.cc:     ' + summary(listag.tail.node.next.cc) + 'head.node.previous.cc: ' + summary(listag.head.node.previous.cc) + 'tail.node.previous.cc: ' + summary(listag.tail.node.previous.cc);
  }, "Removal of a single tag - was `['aa', 'bb']`, now `['bb']`", "id.........type....bb\nthe_first  number  x \nnode:1 aa:0 bb:1 cc:0", function(listag) {
    listag.edit('the_first', {
      tags: ['bb']
    });
    return listag.browse() + '\n' + 'node:' + listag.total.node + ' aa:' + (listag.total.aa || 0) + ' bb:' + (listag.total.bb || 0) + ' cc:' + (listag.total.cc || 0);
  }, "Without a `config.tags` property (but changing cargo), tags do not change", "id.........type....bb\nthe_first  string  x \nnode:1 aa:0 bb:1 cc:0", function(listag) {
    listag.edit('the_first', {
      cargo: 'ok'
    });
    return listag.browse() + '\n' + 'node:' + listag.total.node + ' aa:' + (listag.total.aa || 0) + ' bb:' + (listag.total.bb || 0) + ' cc:' + (listag.total.cc || 0);
  }, "With an empty `config.tags` array (but changing cargo), no tags remain", "id.........type..\nthe_first  number\nnode:1 aa:0 bb:0 cc:0", function(listag) {
    listag.edit('the_first', {
      cargo: 123,
      tags: []
    });
    return listag.browse() + '\n' + 'node:' + listag.total.node + ' aa:' + (listag.total.aa || 0) + ' bb:' + (listag.total.bb || 0) + ' cc:' + (listag.total.cc || 0);
  }, "An array with arbitrary properties - also, added another node", "id..........type....aa..bb..cc\nthe_first   number  x   x     \nthe_second  number  x       x \nnode:2 aa:2 bb:1 cc:1\n\nhead.node: the_first\ntail.node: the_second\nhead.aa:   the_first\ntail.aa:   the_second\nhead.bb:   the_first\ntail.bb:   the_first\nhead.cc:   the_second\ntail.cc:   the_second\n\nhead.node.next.aa:     the_second\ntail.node.next.aa:     null\nhead.node.previous.aa: null\ntail.node.previous.aa: the_first\nhead.node.next.bb:     null\ntail.node.next.bb:     undefined\nhead.node.previous.bb: null\ntail.node.previous.bb: undefined\nhead.node.next.cc:     undefined\ntail.node.next.cc:     null\nhead.node.previous.cc: undefined\ntail.node.previous.cc: null" + '\n', function(listag) {
    var summary, tags;
    summary = function(node) {
      return (node ? node.id : node) + '\n';
    };
    tags = ['aa', 'bb'];
    tags.thing = 'Unexpected!';
    listag.edit('the_first', {
      tags: tags
    });
    listag.add(55, 'the_second', ['aa', 'cc']);
    return listag.browse() + '\n' + 'node:' + listag.total.node + ' aa:' + (listag.total.aa || 0) + ' bb:' + (listag.total.bb || 0) + ' cc:' + (listag.total.cc || 0) + '\n\n' + 'head.node: ' + summary(listag.head.node) + 'tail.node: ' + summary(listag.tail.node) + 'head.aa:   ' + summary(listag.head.aa) + 'tail.aa:   ' + summary(listag.tail.aa) + 'head.bb:   ' + summary(listag.head.bb) + 'tail.bb:   ' + summary(listag.tail.bb) + 'head.cc:   ' + summary(listag.head.cc) + 'tail.cc:   ' + summary(listag.tail.cc) + '\n' + 'head.node.next.aa:     ' + summary(listag.head.node.next.aa) + 'tail.node.next.aa:     ' + summary(listag.tail.node.next.aa) + 'head.node.previous.aa: ' + summary(listag.head.node.previous.aa) + 'tail.node.previous.aa: ' + summary(listag.tail.node.previous.aa) + 'head.node.next.bb:     ' + summary(listag.head.node.next.bb) + 'tail.node.next.bb:     ' + summary(listag.tail.node.next.bb) + 'head.node.previous.bb: ' + summary(listag.head.node.previous.bb) + 'tail.node.previous.bb: ' + summary(listag.tail.node.previous.bb) + 'head.node.next.cc:     ' + summary(listag.head.node.next.cc) + 'tail.node.next.cc:     ' + summary(listag.tail.node.next.cc) + 'head.node.previous.cc: ' + summary(listag.head.node.previous.cc) + 'tail.node.previous.cc: ' + summary(listag.tail.node.previous.cc) + '';
  }, "After editing a node’s tags, `head`, `tail`, `previous` and `next` are as expected", "id..........type....aa..bb..cc\nthe_first   number  x   x     \nthe_second  number      x   x \nnode:2 aa:1 bb:2 cc:1\n\nhead.node: the_first\ntail.node: the_second\nhead.aa:   the_first\ntail.aa:   the_first\nhead.bb:   the_first\ntail.bb:   the_second\nhead.cc:   the_second\ntail.cc:   the_second\n\nhead.node.next.aa:     null\ntail.node.next.aa:     undefined\nhead.node.previous.aa: null\ntail.node.previous.aa: undefined\nhead.node.next.bb:     the_second\ntail.node.next.bb:     null\nhead.node.previous.bb: null\ntail.node.previous.bb: the_first\nhead.node.next.cc:     undefined\ntail.node.next.cc:     null\nhead.node.previous.cc: undefined\ntail.node.previous.cc: null" + '\n', function(listag) {
    var summary;
    summary = function(node) {
      return (node ? node.id : node) + '\n';
    };
    listag.edit('the_second', {
      tags: ['bb', 'cc']
    });
    return listag.browse() + '\n' + 'node:' + listag.total.node + ' aa:' + (listag.total.aa || 0) + ' bb:' + (listag.total.bb || 0) + ' cc:' + (listag.total.cc || 0) + '\n\n' + 'head.node: ' + summary(listag.head.node) + 'tail.node: ' + summary(listag.tail.node) + 'head.aa:   ' + summary(listag.head.aa) + 'tail.aa:   ' + summary(listag.tail.aa) + 'head.bb:   ' + summary(listag.head.bb) + 'tail.bb:   ' + summary(listag.tail.bb) + 'head.cc:   ' + summary(listag.head.cc) + 'tail.cc:   ' + summary(listag.tail.cc) + '\n' + 'head.node.next.aa:     ' + summary(listag.head.node.next.aa) + 'tail.node.next.aa:     ' + summary(listag.tail.node.next.aa) + 'head.node.previous.aa: ' + summary(listag.head.node.previous.aa) + 'tail.node.previous.aa: ' + summary(listag.tail.node.previous.aa) + 'head.node.next.bb:     ' + summary(listag.head.node.next.bb) + 'tail.node.next.bb:     ' + summary(listag.tail.node.next.bb) + 'head.node.previous.bb: ' + summary(listag.head.node.previous.bb) + 'tail.node.previous.bb: ' + summary(listag.tail.node.previous.bb) + 'head.node.next.cc:     ' + summary(listag.head.node.next.cc) + 'tail.node.next.cc:     ' + summary(listag.tail.node.next.cc) + 'head.node.previous.cc: ' + summary(listag.head.node.previous.cc) + 'tail.node.previous.cc: ' + summary(listag.tail.node.previous.cc) + '';
  }, "More tag editing still produces proper `head`, `tail`, `previous` and `next`", "id..........type....aa..bb..cc\nthe_first   number  x       x \nthe_second  number      x   x \nnode:2 aa:1 bb:1 cc:2\n\nhead.node: the_first\ntail.node: the_second\nhead.aa:   the_first\ntail.aa:   the_first\nhead.bb:   the_second\ntail.bb:   the_second\nhead.cc:   the_first\ntail.cc:   the_second\n\nhead.node.next.aa:     null\ntail.node.next.aa:     undefined\nhead.node.previous.aa: null\ntail.node.previous.aa: undefined\nhead.node.next.bb:     undefined\ntail.node.next.bb:     null\nhead.node.previous.bb: undefined\ntail.node.previous.bb: null\nhead.node.next.cc:     the_second\ntail.node.next.cc:     null\nhead.node.previous.cc: null\ntail.node.previous.cc: the_first" + '\n', function(listag) {
    var summary;
    summary = function(node) {
      return (node ? node.id : node) + '\n';
    };
    listag.edit('the_first', {
      tags: []
    });
    listag.edit('the_first', {
      tags: ['aa', 'cc']
    });
    return listag.browse() + '\n' + 'node:' + listag.total.node + ' aa:' + (listag.total.aa || 0) + ' bb:' + (listag.total.bb || 0) + ' cc:' + (listag.total.cc || 0) + '\n\n' + 'head.node: ' + summary(listag.head.node) + 'tail.node: ' + summary(listag.tail.node) + 'head.aa:   ' + summary(listag.head.aa) + 'tail.aa:   ' + summary(listag.tail.aa) + 'head.bb:   ' + summary(listag.head.bb) + 'tail.bb:   ' + summary(listag.tail.bb) + 'head.cc:   ' + summary(listag.head.cc) + 'tail.cc:   ' + summary(listag.tail.cc) + '\n' + 'head.node.next.aa:     ' + summary(listag.head.node.next.aa) + 'tail.node.next.aa:     ' + summary(listag.tail.node.next.aa) + 'head.node.previous.aa: ' + summary(listag.head.node.previous.aa) + 'tail.node.previous.aa: ' + summary(listag.tail.node.previous.aa) + 'head.node.next.bb:     ' + summary(listag.head.node.next.bb) + 'tail.node.next.bb:     ' + summary(listag.tail.node.next.bb) + 'head.node.previous.bb: ' + summary(listag.head.node.previous.bb) + 'tail.node.previous.bb: ' + summary(listag.tail.node.previous.bb) + 'head.node.next.cc:     ' + summary(listag.head.node.next.cc) + 'tail.node.next.cc:     ' + summary(listag.tail.node.next.cc) + 'head.node.previous.cc: ' + summary(listag.head.node.previous.cc) + 'tail.node.previous.cc: ' + summary(listag.tail.node.previous.cc) + '';
  }, "`tags` exceptions", tudor["throw"], "A string", "/listag/src/Listag.litcoffee Listag::edit()\n  config.tags is type string not array", function(listag) {
    return listag.edit('the_first', {
      tags: 'nope'
    });
  }, "Contains a number", "/listag/src/Listag.litcoffee Listag::edit()\n  config.tags[2] is type number not string", function(listag) {
    return listag.edit('the_first', {
      tags: ['ok', 'fine', 123456, 'uh_oh']
    });
  }, "Contains an empty string", "/listag/src/Listag.litcoffee Listag::edit()\n  config.tags[3] fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.edit('the_first', {
      tags: ['no', 'empties', 'allowed', '']
    });
  }, "Contains a string starting with a digit", "/listag/src/Listag.litcoffee Listag::edit()\n  config.tags[0] fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.edit('the_first', {
      tags: ['123abc', 'nope']
    });
  }, "Contains a string starting with an uppercase letter", "/listag/src/Listag.litcoffee Listag::edit()\n  config.tags[3] fails ^[a-z]\\w{1,23}$", function(listag) {
    return listag.edit('the_first', {
      tags: ['must', 'be', 'only', 'Lowercase']
    });
  }, "Contains the special string 'node'", "/listag/src/Listag.litcoffee Listag::edit()\n  config.tags[0] is the special tag 'node'", function(listag) {
    return listag.edit('the_first', {
      tags: ['node', 'is', 'reserved']
    });
  }, "Contains duplicate tags at indices 1 and 3", "/listag/src/Listag.litcoffee Listag::edit()\n  config.tags[3] is a duplicate of config.tags[1]", function(listag) {
    return listag.edit('the_first', {
      tags: ['here', 'again', 'there', 'again']
    });
  }, "Contains many duplicate tags, including indices 0 and 2", "/listag/src/Listag.litcoffee Listag::edit()\n  config.tags[2] is a duplicate of config.tags[0]", function(listag) {
    return listag.edit('the_first', {
      tags: ['aa', 'bb', 'aa', 'aa', 'bb']
    });
  }
]);

oo.lock(Listag);

if (oo.F === typeof define && define.amd) {
  define(function() {
    return Listag;
  });
} else if (oo.O === typeof module && module && module.exports) {
  module.exports = Listag;
} else {
  oo.G.Listag = Listag;
}
}).call(this,this);
